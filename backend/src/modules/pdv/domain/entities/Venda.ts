/**
 * Venda Entity (PDV Module)
 * Aggregate Root seguindo DDD
 */

export interface VendaProps {
  id: string;
  clinicId: string;
  caixaId?: string;
  numeroVenda: string;
  patientId?: string;
  vendedorId: string;
  valorSubtotal: number;
  valorDesconto: number;
  valorTotal: number;
  status: 'ABERTA' | 'CONCLUIDA' | 'CANCELADA';
  nfceEmitida: boolean;
  nfceChave?: string;
  observacoes?: string;
  createdAt: Date;
}

export interface VendaItemProps {
  id: string;
  vendaId: string;
  produtoId: string;
  descricao: string;
  quantidade: number;
  valorUnitario: number;
  valorDesconto: number;
  valorTotal: number;
}

export interface VendaPagamentoProps {
  id: string;
  vendaId: string;
  formaPagamento: 'DINHEIRO' | 'CREDITO' | 'DEBITO' | 'PIX' | 'CRYPTO';
  valor: number;
  parcelas: number;
  transacaoId?: string;
  createdAt: Date;
}

export class Venda {
  private props: VendaProps;
  private itens: VendaItemProps[] = [];
  private pagamentos: VendaPagamentoProps[] = [];

  private constructor(props: VendaProps) {
    this.props = props;
  }

  static create(props: Omit<VendaProps, 'id' | 'numeroVenda' | 'createdAt' | 'status' | 'nfceEmitida' | 'valorDesconto' | 'valorTotal'>): Venda {
    return new Venda({
      ...props,
      id: crypto.randomUUID(),
      numeroVenda: '', // Will be generated by DB trigger
      status: 'ABERTA',
      nfceEmitida: false,
      valorDesconto: 0,
      valorTotal: props.valorSubtotal,
      createdAt: new Date(),
    });
  }

  static restore(props: VendaProps): Venda {
    return new Venda(props);
  }

  // Getters
  get id(): string { return this.props.id; }
  get clinicId(): string { return this.props.clinicId; }
  get numeroVenda(): string { return this.props.numeroVenda; }
  get status(): string { return this.props.status; }
  get valorTotal(): number { return this.props.valorTotal; }

  // Domain methods
  adicionarItem(item: Omit<VendaItemProps, 'id' | 'vendaId'>): void {
    if (this.props.status !== 'ABERTA') {
      throw new Error('Não é possível adicionar itens a uma venda não aberta');
    }

    this.itens.push({
      id: crypto.randomUUID(),
      vendaId: this.props.id,
      ...item,
    });

    this.recalcularTotal();
  }

  adicionarPagamento(pagamento: Omit<VendaPagamentoProps, 'id' | 'vendaId' | 'createdAt'>): void {
    this.pagamentos.push({
      id: crypto.randomUUID(),
      vendaId: this.props.id,
      createdAt: new Date(),
      ...pagamento,
    });
  }

  concluir(): void {
    if (this.props.status !== 'ABERTA') {
      throw new Error('Venda já foi concluída ou cancelada');
    }

    const totalPago = this.pagamentos.reduce((sum, p) => sum + p.valor, 0);
    if (totalPago < this.props.valorTotal) {
      throw new Error('Valor pago é inferior ao total da venda');
    }

    this.props.status = 'CONCLUIDA';
  }

  cancelar(motivo: string): void {
    if (this.props.status === 'CANCELADA') {
      throw new Error('Venda já está cancelada');
    }

    this.props.status = 'CANCELADA';
    this.props.observacoes = `CANCELADA: ${motivo}`;
  }

  private recalcularTotal(): void {
    this.props.valorSubtotal = this.itens.reduce((sum, item) => sum + item.valorTotal, 0);
    this.props.valorTotal = this.props.valorSubtotal - this.props.valorDesconto;
  }

  toObject(): VendaProps {
    return { ...this.props };
  }

  getItens(): VendaItemProps[] {
    return [...this.itens];
  }

  getPagamentos(): VendaPagamentoProps[] {
    return [...this.pagamentos];
  }
}
